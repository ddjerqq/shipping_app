@using Application.Services
@using Serilog
@using Domain.Common
@inject IJSRuntime Js
@inject IRecaptchaVerifier RecaptchaVerifier

<div id="recaptcha" data-sitekey="@RecaptchaSiteKey" @attributes="AdditionalAttributes"></div>

@code {
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object> AdditionalAttributes { get; set; } = [];

    private static string RecaptchaSiteKey => "GOOGLE__RECAPTCHA__SITE_KEY".FromEnvRequired();

    private string _captchaResponse = null!;

    public async Task<bool> IsValid(CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(_captchaResponse))
            return false;

        var response = await RecaptchaVerifier.VerifyAsync(_captchaResponse, ct);

        if (response.Success)
            return true;

        Log.Warning("Recaptcha has errors: {Errors}", string.Join(';', response.ErrorCodes));
        ShowWarning($"{Locale.captcha_errors} {string.Join(';', response.ErrorCodes)}");

        return false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // this needs to be delayed because the google recaptcha URL which we use to link the JS
                // is dynamic (the language in it is dynamic) so more often than i like, it is not loading on time
                await Task.Delay(500);
                await Js.InvokeVoidAsync("renderGoogleRecaptcha", DotNetObjectReference.Create(this), "recaptcha", RecaptchaSiteKey);
            }
            catch (JSException ex)
            {
                Log.Error(ex, "failed to load CAPTCHA");
                ShowWarning(Locale.google_recaptcha_error_please_reload);
            }
        }
    }

    [JSInvokable]
    public void OnSuccess(string response)
    {
        _captchaResponse = response;
        Log.Debug("recaptcha response received: {Response}", response);
    }

    [JSInvokable]
    public void OnExpired() => ShowWarning(Locale.captcha_expired_please_do_it_again);
}